# Sync existing Boost submodules (update docs and submodule pointers).
#
# Trigger: repository_dispatch with event_type "start-translation".
# Example: POST /repos/{owner}/{repo}/dispatches
#   Body: {"event_type": "start-translation", "client_payload": {"version": "boost-1.90.0"}}
#
# Submodules list is taken from .gitmodules of ORG/TRANSLATIONS_REPO at master branch
# (only libs/ entries). No new org repos are created; run add-submodules first.
#
# For each lang_code in LANG_CODES:
#   1. Ensures TRANSLATIONS_REPO has a "local-{lang_code}" branch.
#   2. For each submodule: syncs CppDigest master, then handles "local-{lang_code}" in the
#      CppDigest lib repo (creates if missing, or merges master if no open translation PR).
#   3. Updates TRANSLATIONS_REPO master and each "local-{lang_code}" submodule pointer.
#   4. POSTs to Weblate with add_or_update map: {lang_code: [submodules, ...]}.
#
# client_payload:
#   lang_codes: (optional) Comma-separated lang codes (e.g. zh_Hans,ja). Defaults to secrets.LANG_CODES.
#   version: (optional) Boost release ref (e.g. boost-1.90.0). Defaults to develop.
#   extensions: (optional) File extensions for Weblate (e.g. [.adoc, .md]). Default empty.
#
# Required secrets: SYNC_TOKEN, WEBLATE_URL, WEBLATE_TOKEN.
# Optional secret: LANG_CODES (used when lang_codes not in client_payload).

name: Start translation

on:
  repository_dispatch:
    types: [start-translation]

env:
  ORG: CppDigest
  TRANSLATIONS_REPO: boost-docs-translation
  MASTER_BRANCH: master

jobs:
  start-translation:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.SYNC_TOKEN }}

      - name: Checkout master for .gitmodules
        run: git checkout ${{ env.MASTER_BRANCH }}

      - name: Start translation
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.SYNC_TOKEN }}
          LIBS_REF: ${{ github.event.client_payload.version || 'develop' }}
          LANG_CODES: ${{ github.event.client_payload.lang_codes || secrets.LANG_CODES }}
          EXTENSIONS: ${{ github.event.client_payload.extensions || '' }}
          WEBLATE_URL: ${{ secrets.WEBLATE_URL }}
          WEBLATE_TOKEN: ${{ secrets.WEBLATE_TOKEN }}
        run: |
          set -euo pipefail

          [[ -z "${GITHUB_TOKEN:-}" ]] && {
            echo "Error: SYNC_TOKEN secret is not set." >&2
            exit 1
          }

          [[ -z "${LANG_CODES:-}" ]] && {
            echo "Error: lang_codes not set in client_payload or secrets.LANG_CODES." >&2
            exit 1
          }

          [[ -z "${WEBLATE_URL:-}" ]] && {
            echo "Error: WEBLATE_URL secret is not set." >&2
            exit 1
          }

          [[ -z "${WEBLATE_TOKEN:-}" ]] && {
            echo "Error: WEBLATE_TOKEN secret is not set." >&2
            exit 1
          }

          BOT_NAME="Boost-Translation-CI-Bot"
          BOT_EMAIL="Boost-Translation-CI-Bot@$ORG.local"
          BOOST_ORG="whisper67265"
          UPDATES=()
          declare -A add_or_update

          WORK_DIR=$(mktemp -d)
          trap 'rm -rf "$WORK_DIR"' EXIT
          BOOST_WORK="$WORK_DIR/boost"
          ORG_WORK="$WORK_DIR/$ORG"
          TRANS_DIR="$WORK_DIR/translations"
          mkdir -p "$BOOST_WORK" "$ORG_WORK"

          # Configure git credential helper so all github.com pushes are authenticated
          # without embedding tokens in remote URLs.
          gh auth setup-git

          # ── Helpers ──────────────────────────────────────────────────────────

          set_git_bot_config() {
            git -C "$1" config user.email "$BOT_EMAIL"
            git -C "$1" config user.name "$BOT_NAME"
          }

          # ── GitHub API helpers (via gh CLI) ──────────────────────────────────

          repo_exists() { gh repo view "$1/$2" &>/dev/null; }

          # Returns 0 if org/repo has an open PR into local-{lang_code} with head matching
          # "translation-{lang_code}-*".
          has_open_translation_pr() {
            local org="$1" repo="$2" lang_code="$3"
            local base_br="local-${lang_code}"
            gh pr list --repo "$org/$repo" --state open --base "$base_br" --json headRefName \
              --jq ".[] | select(.headRefName | startswith(\"translation-${lang_code}-\")) | .headRefName" \
              2>/dev/null | grep -q .
          }

          # ── Git clone helpers ────────────────────────────────────────────────

          # Clone repo at branch/tag into $3. Pass "keep" as $4 to preserve .git.
          clone_repo() {
            mkdir -p "$3"
            git clone --branch "$2" "$1" "$3"
            [[ "${4:-}" == "keep" ]] || rm -rf "$3/.git"
          }

          # ── Doc-path helpers ─────────────────────────────────────────────────

          # Fetch meta/libraries.json via gh API; emit one doc-path per line.
          get_doc_paths() {
            local repo="$1" ref="$2" json
            json=$(gh api "repos/${BOOST_ORG}/${repo}/contents/meta/libraries.json?ref=${ref}" \
              -H "Accept: application/vnd.github.v3.raw" 2>/dev/null) || return 1
            echo "$json" | jq -r --arg repo "$repo" '
              (if type == "array" then . else [.] end)
              | .[]
              | select(type == "object")
              | select((.name // "") != "" and (.key // "") != "")
              | .key as $key
              | if $key == $repo then "doc"
                elif ($key | startswith($repo + "/")) then ($key[($repo | length + 1):] + "/doc")
                else ($key + "/doc")
                end
            '
          }

          # Prune a cloned repo to only root files + the given doc-path subtrees.
          # E.g. ("doc") → keep all root files + entire doc/.
          #      ("minmax/doc" "string/doc") → keep root files + those two subtrees.
          prune_to_doc_only() {
            local dir="$1"; shift
            local keep_paths=("$@")
            [[ ${#keep_paths[@]} -eq 0 ]] && return

            local first_segs=()
            for p in "${keep_paths[@]}"; do first_segs+=("${p%%/*}"); done

            # Delete root-level dirs not needed by any keep path.
            # Use find instead of glob so dotdirs (e.g. .drone, .github) are included.
            while IFS= read -r item; do
              local name="${item##*/}"
              local needed=0
              for seg in "${first_segs[@]}"; do
                [[ "$name" == "$seg" ]] && { needed=1; break; }
              done
              [[ $needed -eq 0 ]] && rm -rf "$item"
            done < <(find "$dir" -maxdepth 1 -mindepth 1 -type d 2>/dev/null)

            # For paths deeper than one level (e.g. "minmax/doc"), prune the
            # intermediate directory so only the target subdir survives.
            for p in "${keep_paths[@]}"; do
              local first="${p%%/*}"
              [[ "$first" == "$p" ]] && continue  # depth 1 ("doc"): keep entire dir
              local rest_first="${p#${first}/}"; rest_first="${rest_first%%/*}"
              for f in "$dir/$first"/*; do [[ -f "$f" ]] && rm -f "$f"; done
              while IFS= read -r item; do
                local name="${item##*/}"
                [[ "$name" == "$rest_first" ]] || rm -rf "$item"
              done < <(find "$dir/$first" -maxdepth 1 -mindepth 1 -type d 2>/dev/null)
            done
          }

          # ── Organization repo sync helpers ──────────────────────────────────────

          # Wipe dest_repo (except .git), copy pruned source, commit, push master only.
          sync_repo_master() {
            local dest_repo="$1" sub_clone="$2" libs_ref="$3"
            find "$dest_repo" -mindepth 1 -maxdepth 1 ! -name '.git' -exec rm -rf {} +
            cp -r "$sub_clone/." "$dest_repo/"
            set_git_bot_config "$dest_repo"
            git -C "$dest_repo" add -A
            git -C "$dest_repo" commit -m "Update the original documentation of $libs_ref" 2>/dev/null || true
            git -C "$dest_repo" push origin "$MASTER_BRANCH"
          }

          # Merge master into local-{lang_code} and push.
          update_local_merge_from_master() {
            local repo_dir="$1" lang_code="$2"
            local local_br="local-${lang_code}"
            git -C "$repo_dir" fetch origin "$MASTER_BRANCH"
            git -C "$repo_dir" fetch origin "$local_br" 2>/dev/null || true
            git -C "$repo_dir" checkout -B "$local_br" "origin/$local_br"
            git -C "$repo_dir" merge "origin/$MASTER_BRANCH"
            git -C "$repo_dir" push origin "${local_br}:${local_br}"
          }

          # Copy create-tag.yml asset into a CppDigest lib repo.
          add_create_tag_workflow() {
            local repo_dir="$1" wf_dir="$1/.github/workflows"
            mkdir -p "$wf_dir"
            cp "$GITHUB_WORKSPACE/.github/workflows/assets/create-tag.yml" \
              "$wf_dir/create-tag.yml"
            git -C "$repo_dir" add ".github/workflows/create-tag.yml"
            git -C "$repo_dir" commit -m "Add create-tag workflow"
          }

          # Create local-{lang_code} in a CppDigest lib repo from master, with create-tag.yml.
          ensure_local_branch_in_repo() {
            local dest_repo="$1" sub_name="$2" lang_code="$3"
            local local_br="local-${lang_code}"
            if git -C "$dest_repo" ls-remote --exit-code --heads origin "$local_br" &>/dev/null; then
              echo "  Branch $local_br already exists in $sub_name." >&2
              return 0
            fi
            echo "  Creating branch $local_br in $sub_name from $MASTER_BRANCH..." >&2
            git -C "$dest_repo" fetch origin "$MASTER_BRANCH"
            git -C "$dest_repo" checkout -B "$local_br" "origin/$MASTER_BRANCH"
            add_create_tag_workflow "$dest_repo"
            git -C "$dest_repo" push -u origin "$local_br"
            echo "  Created branch $local_br." >&2
          }

          # Handle local-{lang_code} branch in a CppDigest lib repo after master is synced.
          # Returns 0 if submodule should be added to add_or_update[lang_code], 1 otherwise.
          process_local_branch() {
            local dest_repo="$1" sub_name="$2" lang_code="$3"
            local local_br="local-${lang_code}"
            if git -C "$dest_repo" ls-remote --exit-code --heads origin "$local_br" &>/dev/null; then
              if has_open_translation_pr "$ORG" "$sub_name" "$lang_code"; then
                echo "  Open translation PR found for $sub_name ($local_br), skipping." >&2
                return 1
              fi
              update_local_merge_from_master "$dest_repo" "$lang_code"
            else
              ensure_local_branch_in_repo "$dest_repo" "$sub_name" "$lang_code"
            fi
            return 0
          }

          # ── Translations repo helpers ─────────────────────────────────────────

          # Create local-{lang_code} in TRANSLATIONS_REPO from master, stripping libs/ and .gitmodules.
          ensure_local_branch_in_translations() {
            local dir="$1" lang_code="$2"
            local branch="local-${lang_code}"
            if git -C "$dir" ls-remote --exit-code --heads origin "$branch" &>/dev/null; then
              echo "  Branch $branch already exists in $TRANSLATIONS_REPO." >&2
            else
              echo "  Creating branch $branch in $TRANSLATIONS_REPO from $MASTER_BRANCH..." >&2
              git -C "$dir" checkout -B "$MASTER_BRANCH" "origin/$MASTER_BRANCH"
              git -C "$dir" checkout -b "$branch"
              rm -rf "$dir/libs" "$dir/.gitmodules"
              git -C "$dir" rm -rf --cached libs .gitmodules 2>/dev/null || true
              git -C "$dir" commit -m "Init $branch" 2>/dev/null || true
              git -C "$dir" push -u origin "$branch"
              echo "  Created branch $branch." >&2
            fi
          }

          ensure_translations_cloned() {
            [[ -d "$3/.git" ]] && return
            clone_repo "https://github.com/${1}/${2}.git" "$MASTER_BRANCH" "$3" keep
            set_git_bot_config "$3"
          }

          submodule_in_gitmodules() {
            git -C "$1" config --file .gitmodules --get "submodule.${2}.url" &>/dev/null
          }

          update_translations_submodule() {
            local dir="$1" org="$2" sub_name="$3" branch="$4"
            local libs_path="$dir/libs/$sub_name"
            local sub_path="libs/$sub_name"
            local sub_url="https://github.com/${org}/${sub_name}.git"

            if submodule_in_gitmodules "$dir" "$sub_path" && [[ -d "$libs_path" ]]; then
              git -C "$dir" submodule update --init "$sub_path" 2>/dev/null || true
              git -C "$dir" config "submodule.${sub_path}.branch" "$branch"
              if ! git -C "$dir" submodule update --remote "$sub_path"; then
                echo "  submodule update --remote failed for $sub_path" >&2; return 1
              fi
              git -C "$dir" add "$sub_path"
            else
              # Submodule not registered on this branch yet; add it fresh.
              rm -rf "$libs_path" "$dir/.git/modules/$sub_path"
              git -C "$dir" submodule add -b "$branch" "$sub_url" "$sub_path"
              git -C "$dir" add .gitmodules "$sub_path"
            fi
          }

          commit_and_push_translations_branch() {
            local dir="$1" branch="$2" libs_ref="$3" force="${4:-false}"
            git -C "$dir" status --short
            git -C "$dir" commit -m "Update libs submodules to $libs_ref" 2>/dev/null || true
            if [[ "$force" == "true" ]]; then
              git -C "$dir" push --force origin "$branch"
            else
              git -C "$dir" push origin "$branch"
            fi
          }

          # Update one branch of the translations super-repo (checkout → update pointers → push).
          sync_translations_branch() {
            local dir="$1" branch="$2" libs_ref="$3" force="${4:-false}"
            git -C "$dir" checkout -B "$branch" "origin/$branch"
            for sub in "${UPDATES[@]}"; do
              update_translations_submodule "$dir" "$ORG" "$sub" "$branch"
            done
            commit_and_push_translations_branch "$dir" "$branch" "$libs_ref" "$force"
          }

          finalize_translations_repo() {
            local dir="$1" libs_ref="$2"
            [[ ${#UPDATES[@]} -eq 0 ]] && return
            git -C "$dir" fetch origin 2>/dev/null || true
            sync_translations_branch "$dir" "$MASTER_BRANCH" "$libs_ref"
            for lang_code in "${lang_codes_arr[@]}"; do
              sync_translations_branch "$dir" "local-${lang_code}" "$libs_ref" true
            done
          }

          # ── Per-submodule processing ──────────────────────────────────────────

          process_one_submodule() {
            local sub_name="$1" doc_paths

            if ! repo_exists "$ORG" "$sub_name"; then
              echo "  Skipping: $ORG/$sub_name does not exist. Run add-submodules first." >&2
              return 1
            fi

            doc_paths=$(get_doc_paths "$sub_name" "$LIBS_REF") || {
              echo "  No libraries.json, skipping." >&2; return 1
            }
            [[ -z "$doc_paths" ]] && { echo "  No doc paths, skipping." >&2; return 1; }

            local sub_clone="$BOOST_WORK/$sub_name"
            clone_repo "https://github.com/${BOOST_ORG}/${sub_name}.git" \
              "$LIBS_REF" "$sub_clone" || { echo "  Clone failed." >&2; return 1; }

            local -a paths_arr
            mapfile -t paths_arr <<< "$doc_paths"
            prune_to_doc_only "$sub_clone" "${paths_arr[@]}"

            local org_repo_url="https://github.com/${ORG}/${sub_name}.git"
            local dest_repo="$ORG_WORK/$sub_name"
            clone_repo "$org_repo_url" "$MASTER_BRANCH" "$dest_repo" keep || {
              echo "  clone_repo failed." >&2; return 1
            }

            sync_repo_master "$dest_repo" "$sub_clone" "$LIBS_REF"

            local any_added=0
            for lang_code in "${lang_codes_arr[@]}"; do
              if process_local_branch "$dest_repo" "$sub_name" "$lang_code"; then
                if [[ -n "${add_or_update[$lang_code]:-}" ]]; then
                  add_or_update["$lang_code"]+=" $sub_name"
                else
                  add_or_update["$lang_code"]="$sub_name"
                fi
                any_added=1
              fi
            done
            [[ $any_added -eq 1 ]]
          }

          # ── Weblate helpers ───────────────────────────────────────────────────

          # Parse "[zh_Hans, ja]" or "zh_Hans,ja" into one item per line (spaces stripped).
          parse_list() {
            local s="$1"
            s="${s//[[:space:]]/}"
            s="${s#[}"; s="${s%]}"
            [[ -z "$s" ]] && return
            IFS=',' read -ra parts <<< "$s"
            for part in "${parts[@]}"; do
              [[ -n "$part" ]] && echo "$part"
            done
          }

          # Parse "[.adoc, .md]" or '[".adoc",".md"]' into one extension per line.
          parse_extensions() {
            local s="$1"
            s="${s//[[:space:]]/}"; [[ -z "$s" ]] && return
            s="${s#[}"; s="${s%]}"
            local result=()
            IFS=',' read -ra parts <<< "$s"
            for part in "${parts[@]}"; do
              part="${part//\"/}"; part="${part//\'/}"
              [[ -z "$part" ]] && continue
              [[ "$part" == .* ]] || part=".${part}"
              result+=("$part")
            done
            printf '%s\n' "${result[@]}"
          }

          # POST to Weblate add-or-update endpoint (fire-and-forget, 5 s timeout).
          # Payload: {organization, add_or_update: {lang_code: [subs...]}, version, extensions}
          trigger_weblate() {
            local weblate_url="$1" weblate_token="$2" libs_ref="$3" exts_json="$4"

            # Build add_or_update JSON object from associative array.
            local add_or_update_json="{}"
            for lang_code in "${lang_codes_arr[@]}"; do
              local subs="${add_or_update[$lang_code]:-}"
              [[ -z "$subs" ]] && continue
              local subs_json
              subs_json=$(echo "$subs" | tr ' ' '\n' | grep -v '^$' | jq -R . | jq -s .)
              add_or_update_json=$(echo "$add_or_update_json" | \
                jq --arg lc "$lang_code" --argjson s "$subs_json" '. + {($lc): $s}')
            done

            [[ "$add_or_update_json" == "{}" ]] && {
              echo "Weblate skipped: no translations to update." >&2; return
            }

            local payload
            payload=$(jq -n \
              --arg org "$ORG" --arg ver "$libs_ref" \
              --argjson add "$add_or_update_json" --argjson ext "$exts_json" \
              '{organization:$org,add_or_update:$add,version:$ver,extensions:$ext}')

            echo "Weblate trigger parameters:" >&2
            echo "  organization: $ORG" >&2
            echo "  version:      $libs_ref" >&2
            echo "  extensions:   $exts_json" >&2
            echo "  add_or_update:" >&2
            echo "$add_or_update_json" | jq -r 'to_entries[] | "    \(.key): \(.value | join(", "))"' >&2

            curl_exit=0
            curl -s -o /dev/null -m 5 -X POST \
              -H "Authorization: Bearer $weblate_token" \
              -H "Content-Type: application/json" \
              -H "User-Agent: BoostDocsSync/1.0" \
              -d "$payload" \
              "${weblate_url%/}/boost-endpoint/add-or-update/" \
              || curl_exit=$?
            # Exit 28 = timeout; treat as success since this is fire-and-forget.
            if [[ $curl_exit -eq 0 || $curl_exit -eq 28 ]]; then
              echo "Weblate add-or-update triggered." >&2
            else
              echo "Weblate trigger failed (curl exit $curl_exit)." >&2
            fi
          }

          # ── Main ─────────────────────────────────────────────────────────────

          mapfile -t lang_codes_arr < <(parse_list "$LANG_CODES")
          [[ ${#lang_codes_arr[@]} -eq 0 ]] && {
            echo "Error: LANG_CODES parsed to empty list." >&2; exit 1
          }
          echo "Lang codes: ${lang_codes_arr[*]}" >&2

          for lang_code in "${lang_codes_arr[@]}"; do
            add_or_update["$lang_code"]=""
          done

          [[ ! -f .gitmodules ]] && {
            echo "Error: .gitmodules not found (run from translations repo with master checked out)" >&2
            exit 1
          }

          mapfile -t submodule_names < <(
            git config -f .gitmodules --get-regexp 'submodule\..*\.path' 2>/dev/null \
              | awk '{print $2}' | { grep '^libs/' || true; } | sed 's|^libs/||'
          )

          [[ ${#submodule_names[@]} -eq 0 ]] && {
            echo "No libs/ submodules in .gitmodules, nothing to sync." >&2; exit 0
          }

          echo "Syncing ${#submodule_names[@]} submodules from .gitmodules." >&2

          # ── Step 1: ensure TRANSLATIONS_REPO has local-{lang_code} branches ──

          ensure_translations_cloned "$ORG" "$TRANSLATIONS_REPO" "$TRANS_DIR"
          for lang_code in "${lang_codes_arr[@]}"; do
            ensure_local_branch_in_translations "$TRANS_DIR" "$lang_code"
          done

          # ── Step 2: process submodules ────────────────────────────────────────

          total=${#submodule_names[@]}
          for i in "${!submodule_names[@]}"; do
            sub="${submodule_names[$i]}"
            echo "[$(( i + 1 ))/$total] $sub ..." >&2
            if process_one_submodule "$sub"; then
              UPDATES+=("$sub")
            fi
          done

          # ── Step 3: finalize TRANSLATIONS_REPO ───────────────────────────────

          finalize_translations_repo "$TRANS_DIR" "$LIBS_REF"

          # ── Step 4: POST to Weblate ───────────────────────────────────────────

          ext_arr=()
          [[ -n "${EXTENSIONS:-}" ]] && mapfile -t ext_arr < <(parse_extensions "$EXTENSIONS")
          exts_json="[]"
          [[ ${#ext_arr[@]} -gt 0 ]] && \
            exts_json=$(printf '%s\n' "${ext_arr[@]}" | jq -R . | jq -s .)

          trigger_weblate "$WEBLATE_URL" "$WEBLATE_TOKEN" "$LIBS_REF" "$exts_json"

          echo "Done." >&2

