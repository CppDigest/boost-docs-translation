# Sync existing Boost submodules (update docs and submodule pointers).
#
# Trigger: repository_dispatch with event_type "start-translation".
# Example: POST /repos/{owner}/{repo}/dispatches
#   Body: {"event_type": "start-translation", "client_payload": {"version": "boost-1.90.0"}}
#
# Submodules list is taken from .gitmodules of ORG/TRANSLATIONS_REPO at MASTER_BRANCH
# (only libs/ entries). Same update logic as add-submodule; no new submodules are added.
#
# client_payload:
#   lang_codes: (optional) Language code for Weblate (e.g. zh_Hans). Defaults to secrets.LANG_CODES.
#   version: (optional) Boost release ref (e.g. boost-1.90.0). If set: used for both boost repo (.gitmodules)
#     and individual library repos. If omitted: boost repo uses master, library repos use develop.
#   extensions: (optional) List-like or JSON string for Weblate file extensions (e.g. [.adoc, .md]). Default empty.
#
# Required secret: SYNC_TOKEN — PAT with repo (and org repo create) permissions for org.
# Optional secrets (to trigger Weblate add-or-update at end): WEBLATE_URL, WEBLATE_TOKEN, LANG_CODES.

name: Start translation

on:
  repository_dispatch:
    types: [start-translation]

env:
  ORG: CppDigest
  TRANSLATIONS_REPO: boost-docs-translation
  MASTER_BRANCH: master

jobs:
  sync-submodule:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.SYNC_TOKEN }}

      - name: Checkout master for .gitmodules
        run: git checkout ${{ env.MASTER_BRANCH }}

      - name: Sync submodules
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.SYNC_TOKEN }}
          LIBS_REF: ${{ github.event.client_payload.version || 'develop' }}
          LANG_CODES: ${{ github.event.client_payload.lang_codes || secrets.LANG_CODES }}
          EXTENSIONS: ${{ github.event.client_payload.extensions || '' }}
          WEBLATE_URL: ${{ secrets.WEBLATE_URL }}
          WEBLATE_TOKEN: ${{ secrets.WEBLATE_TOKEN }}
        run: |
          set -euo pipefail

          [[ -z "${GITHUB_TOKEN:-}" ]] && {
            echo "Error: SYNC_TOKEN secret is not set." >&2
            exit 1
          }

          [[ -z "${LANG_CODES:-}" ]] && {
            echo "Error: lang_codes not set in client_payload or secrets.LANG_CODES." >&2
            exit 1
          }

          [[ -z "${WEBLATE_URL:-}" ]] && {
            echo "Error: WEBLATE_URL secret is not set." >&2
            exit 1
          }

          [[ -z "${WEBLATE_TOKEN:-}" ]] && {
            echo "Error: WEBLATE_TOKEN secret is not set." >&2
            exit 1
          }

          BOT_NAME="Boost-Translation-CI-Bot"
          BOT_EMAIL="Boost-Translation-CI-Bot@$ORG.local"
          BOOST_ORG="whisper67265"
          MASTER_BR="master"
          LOCAL_BR="local"
          UPDATES=()

          WORK_DIR=$(mktemp -d)
          trap 'rm -rf "$WORK_DIR"' EXIT
          BOOST_WORK="$WORK_DIR/boost"
          ORG_WORK="$WORK_DIR/$ORG"
          TRANS_DIR="$WORK_DIR/translations"
          mkdir -p "$BOOST_WORK" "$ORG_WORK"

          # Configure git credential helper so all github.com pushes are authenticated
          # without embedding tokens in remote URLs.
          gh auth setup-git

          # ── Helpers ──────────────────────────────────────────────────────────

          set_git_bot_config() {
            git -C "$1" config user.email "$BOT_EMAIL"
            git -C "$1" config user.name "$BOT_NAME"
          }

          # ── GitHub API helpers (via gh CLI) ──────────────────────────────────

          repo_exists() { gh repo view "$1/$2" &>/dev/null; }

          create_repo() {
            gh repo create "$1/$2" --public > /dev/null \
              || { echo "Create repo $1/$2 failed" >&2; return 1; }
          }

          set_default_branch() {
            gh api --method PATCH "repos/$1/$2" -f "default_branch=$3" \
              || echo "Warning: set default branch to $3 failed." >&2
          }

          # Returns 0 if org/repo has an open PR with head matching "boost-<repo>-translation-*".
          has_open_translation_pr() {
            gh pr list --repo "$1/$2" --state open --json headRefName \
              --jq ".[] | select(.headRefName | startswith(\"boost-$2-translation-\")) | .headRefName" \
              2>/dev/null | grep -q .
          }

          # ── Git clone helpers ────────────────────────────────────────────────

          # Clone repo at branch/tag into $3. Pass "keep" as $4 to preserve .git.
          clone_repo() {
            mkdir -p "$3"
            git clone --branch "$2" "$1" "$3"
            [[ "${4:-}" == "keep" ]] || rm -rf "$3/.git"
          }

          # ── Doc-path helpers ─────────────────────────────────────────────────

          # Fetch meta/libraries.json via gh API; emit one doc-path per line.
          get_doc_paths() {
            local repo="$1" ref="$2" json
            json=$(gh api "repos/${BOOST_ORG}/${repo}/contents/meta/libraries.json?ref=${ref}" \
              -H "Accept: application/vnd.github.v3.raw" 2>/dev/null) || return 1
            echo "$json" | jq -r --arg repo "$repo" '
              (if type == "array" then . else [.] end)
              | .[]
              | select(type == "object")
              | select((.name // "") != "" and (.key // "") != "")
              | .key as $key
              | if $key == $repo then "doc"
                elif ($key | startswith($repo + "/")) then ($key[($repo | length + 1):] + "/doc")
                else ($key + "/doc")
                end
            '
          }

          # Prune a cloned repo to only root files + the given doc-path subtrees.
          # E.g. ("doc") → keep all root files + entire doc/.
          #      ("minmax/doc" "string/doc") → keep root files + those two subtrees.
          prune_to_doc_only() {
            local dir="$1"; shift
            local keep_paths=("$@")
            [[ ${#keep_paths[@]} -eq 0 ]] && return

            local first_segs=()
            for p in "${keep_paths[@]}"; do first_segs+=("${p%%/*}"); done

            # Delete root-level dirs not needed by any keep path.
            # Use find instead of glob so dotdirs (e.g. .drone, .github) are included.
            while IFS= read -r item; do
              local name="${item##*/}"
              local needed=0
              for seg in "${first_segs[@]}"; do
                [[ "$name" == "$seg" ]] && { needed=1; break; }
              done
              [[ $needed -eq 0 ]] && rm -rf "$item"
            done < <(find "$dir" -maxdepth 1 -mindepth 1 -type d 2>/dev/null)

            # For paths deeper than one level (e.g. "minmax/doc"), prune the
            # intermediate directory so only the target subdir survives.
            for p in "${keep_paths[@]}"; do
              local first="${p%%/*}"
              [[ "$first" == "$p" ]] && continue  # depth 1 ("doc"): keep entire dir
              local rest_first="${p#${first}/}"; rest_first="${rest_first%%/*}"
              for f in "$dir/$first"/*; do [[ -f "$f" ]] && rm -f "$f"; done
              while IFS= read -r item; do
                local name="${item##*/}"
                [[ "$name" == "$rest_first" ]] || rm -rf "$item"
              done < <(find "$dir/$first" -maxdepth 1 -mindepth 1 -type d 2>/dev/null)
            done
          }

          # ── Organization repo sync helpers ──────────────────────────────────────

          update_local_merge_from_master() {
            local repo_dir="$1"
            git -C "$repo_dir" fetch origin "$MASTER_BR"
            git -C "$repo_dir" fetch origin "$LOCAL_BR" 2>/dev/null || true
            git -C "$repo_dir" checkout -B "$LOCAL_BR" "origin/$LOCAL_BR"
            git -C "$repo_dir" merge "origin/$MASTER_BR"
            git -C "$repo_dir" push origin "${LOCAL_BR}:${LOCAL_BR}"
          }

          # Wipe dest_repo (except .git), copy pruned source, commit, push master.
          # Then update the local branch unless an open translation PR exists.
          sync_existing_repo() {
            local dest_repo="$1" sub_clone="$2" libs_ref="$3" org="$4" sub_name="$5"
            find "$dest_repo" -mindepth 1 -maxdepth 1 ! -name '.git' -exec rm -rf {} +
            cp -r "$sub_clone/." "$dest_repo/"
            set_git_bot_config "$dest_repo"
            git -C "$dest_repo" add -A
            git -C "$dest_repo" commit -m "Update the original documentation of $libs_ref" 2>/dev/null || true
            git -C "$dest_repo" push origin "$MASTER_BR"
            if has_open_translation_pr "$org" "$sub_name"; then return; fi
            update_local_merge_from_master "$dest_repo"
          }

          # Copy create-tag.yml asset into repo, patching the branch-prefix placeholder.
          add_create_tag_workflow() {
            local repo_dir="$1" sub_name="$2" wf_dir="$1/.github/workflows"
            mkdir -p "$wf_dir"
            sed "s/boost-json-translation-/boost-${sub_name}-translation-/g" \
              "$GITHUB_WORKSPACE/.github/workflows/assets/create-tag.yml" \
              > "$wf_dir/create-tag.yml"
            git -C "$repo_dir" add ".github/workflows/create-tag.yml"
            git -C "$repo_dir" commit -m "Add create-tag workflow"
          }

          create_new_repo_and_push() {
            local org="$1" sub_name="$2" sub_clone="$3" repo_url="$4" libs_ref="$5"
            create_repo "$org" "$sub_name"
            git -C "$sub_clone" init
            set_git_bot_config "$sub_clone"
            git -C "$sub_clone" add -A
            git -C "$sub_clone" commit -m "Create the original documentation of $libs_ref"
            git -C "$sub_clone" branch -M "$MASTER_BR"
            git -C "$sub_clone" remote remove origin 2>/dev/null || true
            git -C "$sub_clone" remote add origin "$repo_url"
            git -C "$sub_clone" push -u origin "$MASTER_BR"
            git -C "$sub_clone" push origin "$MASTER_BR"
            git -C "$sub_clone" checkout -b "$LOCAL_BR"
            add_create_tag_workflow "$sub_clone" "$sub_name"
            git -C "$sub_clone" push -u origin "$LOCAL_BR"
            set_default_branch "$org" "$sub_name" "$MASTER_BR"
          }

          # ── Translations repo helpers ─────────────────────────────────────────

          ensure_translations_cloned() {
            [[ -d "$3/.git" ]] && return
            clone_repo "https://github.com/${1}/${2}.git" "$MASTER_BR" "$3" keep
            set_git_bot_config "$3"
          }

          submodule_in_gitmodules() {
            git -C "$1" config --file .gitmodules --get "submodule.${2}.url" &>/dev/null
          }

          update_translations_submodule() {
            local dir="$1" org="$2" sub_name="$3" branch="$4"
            local libs_path="$dir/libs/$sub_name"
            local sub_path="libs/$sub_name"
            local sub_url="https://github.com/${org}/${sub_name}.git"

            if submodule_in_gitmodules "$dir" "$sub_path" && [[ -d "$libs_path" ]]; then
              git -C "$dir" submodule update --init "$sub_path" 2>/dev/null || true
              git -C "$dir" config "submodule.${sub_path}.branch" "$branch"
              if ! git -C "$dir" submodule update --remote "$sub_path"; then
                echo "  submodule update --remote failed for $sub_path" >&2; return 1
              fi
              git -C "$dir" add "$sub_path"
            else
              # Submodule not registered on this branch yet; add it fresh.
              rm -rf "$libs_path" "$dir/.git/modules/$sub_path"
              git -C "$dir" submodule add -b "$branch" "$sub_url" "$sub_path"
              git -C "$dir" add .gitmodules "$sub_path"
            fi
          }

          commit_and_push_translations_branch() {
            local dir="$1" branch="$2" libs_ref="$3" force="${4:-false}"
            git -C "$dir" status --short
            git -C "$dir" commit -m "Update libs submodules to $libs_ref" 2>/dev/null || true
            if [[ "$force" == "true" ]]; then
              git -C "$dir" push --force origin "$branch"
            else
              git -C "$dir" push origin "$branch"
            fi
          }

          # Update one branch of the translations super-repo (checkout → update pointers → push).
          sync_translations_branch() {
            local dir="$1" branch="$2" libs_ref="$3" force="${4:-false}"
            git -C "$dir" checkout -B "$branch" "origin/$branch"
            for sub in "${UPDATES[@]}"; do
              update_translations_submodule "$dir" "$ORG" "$sub" "$branch"
            done
            commit_and_push_translations_branch "$dir" "$branch" "$libs_ref" "$force"
          }

          finalize_translations_repo() {
            local dir="$1" libs_ref="$2"
            [[ ${#UPDATES[@]} -eq 0 ]] && return
            git -C "$dir" fetch origin 2>/dev/null || true
            sync_translations_branch "$dir" "$MASTER_BR" "$libs_ref"
            sync_translations_branch "$dir" "$LOCAL_BR" "$libs_ref" true
          }

          # ── Per-submodule processing ──────────────────────────────────────────

          process_one_submodule() {
            local sub_name="$1" doc_paths
            doc_paths=$(get_doc_paths "$sub_name" "$LIBS_REF") || {
              echo "  No libraries.json, skipping." >&2; return 1
            }
            [[ -z "$doc_paths" ]] && { echo "  No doc paths, skipping." >&2; return 1; }

            local sub_clone="$BOOST_WORK/$sub_name"
            clone_repo "https://github.com/${BOOST_ORG}/${sub_name}.git" \
              "$LIBS_REF" "$sub_clone" || { echo "  Clone failed." >&2; return 1; }

            local -a paths_arr
            mapfile -t paths_arr <<< "$doc_paths"
            prune_to_doc_only "$sub_clone" "${paths_arr[@]}"

            local org_repo_url="https://github.com/${ORG}/${sub_name}.git"
            if repo_exists "$ORG" "$sub_name"; then
              local dest_repo="$ORG_WORK/$sub_name"
              clone_repo "$org_repo_url" "$MASTER_BR" "$dest_repo" keep || {
                echo "  clone_repo failed." >&2; return 1
              }
              sync_existing_repo "$dest_repo" "$sub_clone" "$LIBS_REF" "$ORG" "$sub_name"
            else
              create_new_repo_and_push \
                "$ORG" "$sub_name" "$sub_clone" "$org_repo_url" "$LIBS_REF"
            fi
          }

          # ── Weblate helpers ───────────────────────────────────────────────────

          # Parse "[.adoc, .md]" or '[".adoc",".md"]' into one extension per line.
          parse_extensions() {
            local s="$1"
            s="${s//[[:space:]]/}"; [[ -z "$s" ]] && return
            s="${s#[}"; s="${s%]}"
            local result=()
            IFS=',' read -ra parts <<< "$s"
            for part in "${parts[@]}"; do
              part="${part//\"/}"; part="${part//\'/}"
              [[ -z "$part" ]] && continue
              [[ "$part" == .* ]] || part=".${part}"
              result+=("$part")
            done
            printf '%s\n' "${result[@]}"
          }

          # POST to Weblate add-or-update endpoint (fire-and-forget, 5 s timeout).
          trigger_weblate() {
            local weblate_url="$1" weblate_token="$2" lang_code="$3" libs_ref="$4"
            shift 4
            local extensions=("$@")
            [[ ${#UPDATES[@]} -eq 0 ]] && return

            local subs_json exts_json
            subs_json=$(printf '%s\n' "${UPDATES[@]}" | jq -R . | jq -s .)
            if [[ ${#extensions[@]} -gt 0 ]]; then
              exts_json=$(printf '%s\n' "${extensions[@]}" | jq -R . | jq -s .)
            else
              exts_json="[]"
            fi

            curl_exit=0
            curl -s -o /dev/null -m 5 -X POST \
              -H "Authorization: Bearer $weblate_token" \
              -H "Content-Type: application/json" \
              -H "User-Agent: BoostDocsSync/1.0" \
              -d "$(jq -n \
                    --arg org "$ORG" --argjson subs "$subs_json" \
                    --arg lang "$lang_code" --arg ver "$libs_ref" --argjson exts "$exts_json" \
                    '{organization:$org,submodules:$subs,lang_code:$lang,version:$ver,extensions:$exts}')" \
              "${weblate_url%/}/boost-endpoint/add-or-update/" \
              || curl_exit=$?
            # Exit 28 = timeout; treat as success since this is fire-and-forget.
            if [[ $curl_exit -eq 0 || $curl_exit -eq 28 ]]; then
              echo "Weblate add-or-update triggered." >&2
            else
              echo "Weblate trigger failed (curl exit $curl_exit)." >&2
            fi
          }

          # ── Main ─────────────────────────────────────────────────────────────

          [[ ! -f .gitmodules ]] && {
            echo "Error: .gitmodules not found (run from translations repo with master checked out)" >&2
            exit 1
          }

          mapfile -t submodule_names < <(
            git config -f .gitmodules --get-regexp 'submodule\..*\.path' 2>/dev/null \
              | awk '{print $2}' | { grep '^libs/' || true; } | sed 's|^libs/||'
          )

          [[ ${#submodule_names[@]} -eq 0 ]] && {
            echo "No libs/ submodules in .gitmodules, nothing to sync." >&2; exit 0
          }

          echo "Syncing ${#submodule_names[@]} submodules from .gitmodules." >&2

          total=${#submodule_names[@]}
          for i in "${!submodule_names[@]}"; do
            sub="${submodule_names[$i]}"
            echo "[$(( i + 1 ))/$total] $sub ..." >&2
            if process_one_submodule "$sub"; then
              ensure_translations_cloned "$ORG" "$TRANSLATIONS_REPO" "$TRANS_DIR"
              UPDATES+=("$sub")
            fi
          done

          [[ -d "$TRANS_DIR/.git" ]] && finalize_translations_repo "$TRANS_DIR" "$LIBS_REF"

          if [[ -n "${WEBLATE_URL:-}" && -n "${WEBLATE_TOKEN:-}" && ${#UPDATES[@]} -gt 0 ]]; then
            any_open_pr=0
            for sub in "${UPDATES[@]}"; do
              has_open_translation_pr "$ORG" "$sub" && { any_open_pr=1; break; }
            done
            if [[ $any_open_pr -eq 0 ]]; then
              ext_arr=()
              [[ -n "${EXTENSIONS:-}" ]] && mapfile -t ext_arr < <(parse_extensions "$EXTENSIONS")
              trigger_weblate "$WEBLATE_URL" "$WEBLATE_TOKEN" \
                "$LANG_CODE" "$LIBS_REF" "${ext_arr[@]+"${ext_arr[@]}"}"
            else
              echo "Weblate skipped: open translation PR(s) found for one or more submodules." >&2
            fi
          else
            if [[ ${#UPDATES[@]} -gt 0 ]]; then
              echo "Weblate skipped: WEBLATE_URL or WEBLATE_TOKEN secret not set." >&2
            fi
          fi

          echo "Done." >&2

