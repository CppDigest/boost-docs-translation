# Add new Boost Submodules from boostorg/boost to organization.
#
# Trigger: repository_dispatch with event_type "add-submodules".
# Example: POST /repos/{owner}/{repo}/dispatches
#   Body: {"event_type": "add-submodules", "client_payload": {"version": "boost-1.90.0"}}
#
# client_payload:
#   version: (optional) Boost release ref (e.g. boost-1.90.0). Used for both library repos and .gitmodules
#     auto-discovery. If omitted: library repos use develop, .gitmodules uses develop.
#   submodules: (optional) List-like string of submodule names (e.g. [algorithm, system]). If set, .gitmodules is not fetched.
#   lang_codes: (optional) Language code for Weblate (e.g. zh_Hans). Defaults to secrets.LANG_CODES.
#
# Required secret: SYNC_TOKEN — PAT with repo (and org repo create) permissions for organization.
# Optional secrets: LANG_CODES.

name: Add submodules

on:
  repository_dispatch:
    types: [add-submodules]

env:
  ORG: CppDigest
  TRANSLATIONS_REPO: boost-docs-translation

jobs:
  add-submodules:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.SYNC_TOKEN }}

      - name: Add submodules
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.SYNC_TOKEN }}
          LIBS_REF: ${{ github.event.client_payload.version || 'develop' }}
          SUBMODULES: ${{ github.event.client_payload.submodules || '' }}
          LANG_CODES: ${{ github.event.client_payload.lang_codes || secrets.LANG_CODES }}
        run: |
          set -euo pipefail

          [[ -z "${GITHUB_TOKEN:-}" ]] && {
            echo "Error: SYNC_TOKEN secret is not set." >&2
            exit 1
          }

          [[ -z "${LANG_CODES:-}" ]] && {
            echo "Error: lang_codes not set in client_payload or secrets.LANG_CODES." >&2
            exit 1
          }

          BOT_NAME="Boost-Translation-CI-Bot"
          BOT_EMAIL="Boost-Translation-CI-Bot@$ORG.local"
          BOOST_ORG="whisper67265"
          MASTER_BRANCH="master"
          UPDATES=()

          WORK_DIR=$(mktemp -d)
          trap 'rm -rf "$WORK_DIR"' EXIT
          BOOST_WORK="$WORK_DIR/boost"
          TRANS_DIR="$WORK_DIR/translations"
          mkdir -p "$BOOST_WORK"

          # Configure git credential helper so all github.com pushes are authenticated
          # without embedding tokens in remote URLs.
          gh auth setup-git

          # ── Helpers ──────────────────────────────────────────────────────────

          set_git_bot_config() {
            git -C "$1" config user.email "$BOT_EMAIL"
            git -C "$1" config user.name "$BOT_NAME"
          }

          # ── GitHub API helpers (via gh CLI) ──────────────────────────────────

          repo_exists() { gh repo view "$1/$2" &>/dev/null; }

          create_repo() {
            gh repo create "$1/$2" --public > /dev/null \
              || { echo "Create repo $1/$2 failed" >&2; return 1; }
          }

          set_default_branch() {
            gh api --method PATCH "repos/$1/$2" -f "default_branch=$3" \
              || echo "Warning: set default branch to $3 failed." >&2
          }

          # ── Git clone helpers ────────────────────────────────────────────────

          # Clone repo at branch/tag into $3. Pass "keep" as $4 to preserve .git.
          clone_repo() {
            mkdir -p "$3"
            git clone --branch "$2" "$1" "$3"
            [[ "${4:-}" == "keep" ]] || rm -rf "$3/.git"
          }

          # ── Doc-path helpers ─────────────────────────────────────────────────

          # Fetch meta/libraries.json via gh API; emit one doc-path per line.
          get_doc_paths() {
            local repo="$1" ref="$2" json
            json=$(gh api "repos/${BOOST_ORG}/${repo}/contents/meta/libraries.json?ref=${ref}" \
              -H "Accept: application/vnd.github.v3.raw" 2>/dev/null) || return 1
            echo "$json" | jq -r --arg repo "$repo" '
              (if type == "array" then . else [.] end)
              | .[]
              | select(type == "object")
              | select((.name // "") != "" and (.key // "") != "")
              | .key as $key
              | if $key == $repo then "doc"
                elif ($key | startswith($repo + "/")) then ($key[($repo | length + 1):] + "/doc")
                else ($key + "/doc")
                end
            '
          }

          # Prune a cloned repo to only root files + the given doc-path subtrees.
          # E.g. ("doc") → keep all root files + entire doc/.
          #      ("minmax/doc" "string/doc") → keep root files + those two subtrees.
          prune_to_doc_only() {
            local dir="$1"; shift
            local keep_paths=("$@")
            [[ ${#keep_paths[@]} -eq 0 ]] && return

            local first_segs=()
            for p in "${keep_paths[@]}"; do first_segs+=("${p%%/*}"); done

            # Delete root-level dirs not needed by any keep path.
            # Use find instead of glob so dotdirs (e.g. .drone, .github) are included.
            while IFS= read -r item; do
              local name="${item##*/}"
              local needed=0
              for seg in "${first_segs[@]}"; do
                [[ "$name" == "$seg" ]] && { needed=1; break; }
              done
              [[ $needed -eq 0 ]] && rm -rf "$item"
            done < <(find "$dir" -maxdepth 1 -mindepth 1 -type d 2>/dev/null)

            # For paths deeper than one level (e.g. "minmax/doc"), prune the
            # intermediate directory so only the target subdir survives.
            for p in "${keep_paths[@]}"; do
              local first="${p%%/*}"
              [[ "$first" == "$p" ]] && continue  # depth 1 ("doc"): keep entire dir
              local rest_first="${p#${first}/}"; rest_first="${rest_first%%/*}"
              for f in "$dir/$first"/*; do [[ -f "$f" ]] && rm -f "$f"; done
              while IFS= read -r item; do
                local name="${item##*/}"
                [[ "$name" == "$rest_first" ]] || rm -rf "$item"
              done < <(find "$dir/$first" -maxdepth 1 -mindepth 1 -type d 2>/dev/null)
            done
          }

          # ── Organization repo helpers ────────────────────────────────────────

          # Copy create-tag.yml asset into repo.
          add_create_tag_workflow() {
            local repo_dir="$1" wf_dir="$1/.github/workflows"
            mkdir -p "$wf_dir"
            cp "$GITHUB_WORKSPACE/.github/workflows/assets/create-tag.yml" \
              "$wf_dir/create-tag.yml"
            git -C "$repo_dir" add ".github/workflows/create-tag.yml"
            git -C "$repo_dir" commit -m "Add create-tag workflow"
          }

          create_new_repo_and_push() {
            local org="$1" sub_name="$2" sub_clone="$3" repo_url="$4" libs_ref="$5"
            create_repo "$org" "$sub_name"
            git -C "$sub_clone" init
            set_git_bot_config "$sub_clone"
            git -C "$sub_clone" add -A
            git -C "$sub_clone" commit -m "Create the original documentation of $libs_ref"
            git -C "$sub_clone" branch -M "$MASTER_BRANCH"
            git -C "$sub_clone" remote remove origin 2>/dev/null || true
            git -C "$sub_clone" remote add origin "$repo_url"
            git -C "$sub_clone" push -u origin "$MASTER_BRANCH"
            git -C "$sub_clone" push origin "$MASTER_BRANCH"
            for lang_code in "${lang_codes_arr[@]}"; do
              local local_br="local-${lang_code}"
              git -C "$sub_clone" checkout -B "$local_br" "$MASTER_BRANCH"
              add_create_tag_workflow "$sub_clone"
              git -C "$sub_clone" push -u origin "$local_br"
            done
            set_default_branch "$org" "$sub_name" "$MASTER_BRANCH"
          }

          # ── Translations repo helpers ─────────────────────────────────────────

          ensure_local_branch_in_translations() {
            local dir="$1" lang_code="$2"
            local branch="local-${lang_code}"
            if git -C "$dir" ls-remote --exit-code --heads origin "$branch" &>/dev/null; then
              echo "  Branch $branch already exists in $TRANSLATIONS_REPO." >&2
            else
              echo "  Creating branch $branch in $TRANSLATIONS_REPO from $MASTER_BRANCH..." >&2
              git -C "$dir" checkout -B "$MASTER_BRANCH" "origin/$MASTER_BRANCH"
              git -C "$dir" checkout -b "$branch"
              rm -rf "$dir/libs" "$dir/.gitmodules"
              git -C "$dir" rm -rf --cached libs .gitmodules 2>/dev/null || true
              git -C "$dir" commit -m "Init $branch" 2>/dev/null || true
              git -C "$dir" push -u origin "$branch"
              echo "  Created branch $branch." >&2
            fi
          }

          ensure_translations_cloned() {
            [[ -d "$3/.git" ]] && return
            clone_repo "https://github.com/${1}/${2}.git" "$MASTER_BRANCH" "$3" keep
            set_git_bot_config "$3"
          }

          submodule_in_gitmodules() {
            git -C "$1" config --file .gitmodules --get "submodule.${2}.url" &>/dev/null
          }

          update_translations_submodule() {
            local dir="$1" org="$2" sub_name="$3" branch="$4"
            local libs_path="$dir/libs/$sub_name"
            local sub_path="libs/$sub_name"
            local sub_url="https://github.com/${org}/${sub_name}.git"

            if submodule_in_gitmodules "$dir" "$sub_path" && [[ -d "$libs_path" ]]; then
              git -C "$dir" submodule update --init "$sub_path" 2>/dev/null || true
              git -C "$dir" config "submodule.${sub_path}.branch" "$branch"
              if ! git -C "$dir" submodule update --remote "$sub_path"; then
                echo "  submodule update --remote failed for $sub_path" >&2; return 1
              fi
              git -C "$dir" add "$sub_path"
            else
              # Submodule not registered on this branch yet; add it fresh.
              rm -rf "$libs_path" "$dir/.git/modules/$sub_path"
              git -C "$dir" submodule add -b "$branch" "$sub_url" "$sub_path"
              git -C "$dir" add .gitmodules "$sub_path"
            fi
          }

          commit_and_push_translations_branch() {
            local dir="$1" branch="$2" libs_ref="$3" force="${4:-false}"
            git -C "$dir" status --short
            git -C "$dir" commit -m "Update libs submodules to $libs_ref" 2>/dev/null || true
            if [[ "$force" == "true" ]]; then
              git -C "$dir" push --force origin "$branch"
            else
              git -C "$dir" push origin "$branch"
            fi
          }

          # Update one branch of the translations super-repo (checkout → update pointers → push).
          sync_translations_branch() {
            local dir="$1" branch="$2" libs_ref="$3" force="${4:-false}"
            git -C "$dir" checkout -B "$branch" "origin/$branch"
            for sub in "${UPDATES[@]}"; do
              update_translations_submodule "$dir" "$ORG" "$sub" "$branch"
            done
            commit_and_push_translations_branch "$dir" "$branch" "$libs_ref" "$force"
          }

          finalize_translations_repo() {
            local dir="$1" libs_ref="$2"
            [[ ${#UPDATES[@]} -eq 0 ]] && return
            git -C "$dir" fetch origin 2>/dev/null || true
            sync_translations_branch "$dir" "$MASTER_BRANCH" "$libs_ref"
            for lang_code in "${lang_codes_arr[@]}"; do
              sync_translations_branch "$dir" "local-${lang_code}" "$libs_ref" true
            done
          }

          # ── Per-submodule processing ──────────────────────────────────────────

          process_one_submodule() {
            local sub_name="$1" doc_paths

            if repo_exists "$ORG" "$sub_name"; then
              echo "  Skipping: $ORG/$sub_name already exists." >&2; return 1
            fi

            doc_paths=$(get_doc_paths "$sub_name" "$LIBS_REF") || {
              echo "  No libraries.json, skipping." >&2; return 1
            }
            [[ -z "$doc_paths" ]] && { echo "  No doc paths, skipping." >&2; return 1; }

            local sub_clone="$BOOST_WORK/$sub_name"
            clone_repo "https://github.com/${BOOST_ORG}/${sub_name}.git" \
              "$LIBS_REF" "$sub_clone" || { echo "  Clone failed." >&2; return 1; }

            local -a paths_arr
            mapfile -t paths_arr <<< "$doc_paths"
            prune_to_doc_only "$sub_clone" "${paths_arr[@]}"

            local org_repo_url="https://github.com/${ORG}/${sub_name}.git"
            create_new_repo_and_push "$ORG" "$sub_name" "$sub_clone" "$org_repo_url" "$LIBS_REF"
          }

          # ── Main ─────────────────────────────────────────────────────────────

          # Parse "[zh_Hans, en]" or "zh_Hans,en" into one code per line.
          parse_list() {
            local s="$1"
            s="${s//[[:space:]]/}"
            s="${s#[}"; s="${s%]}"
            [[ -z "$s" ]] && return
            IFS=',' read -ra parts <<< "$s"
            for part in "${parts[@]}"; do
              [[ -n "$part" ]] && echo "$part"
            done
          }

          mapfile -t lang_codes_arr < <(parse_list "$LANG_CODES")
          [[ ${#lang_codes_arr[@]} -eq 0 ]] && {
            echo "Error: LANG_CODES parsed to empty list." >&2; exit 1
          }
          echo "Lang codes: ${lang_codes_arr[*]}" >&2

          # ── Step 1: ensure TRANSLATIONS_REPO has local-{lang_code} branches ──

          ensure_translations_cloned "$ORG" "$TRANSLATIONS_REPO" "$TRANS_DIR"
          for lang_code in "${lang_codes_arr[@]}"; do
            ensure_local_branch_in_translations "$TRANS_DIR" "$lang_code"
          done

          # ── Step 2: process submodules ────────────────────────────────────────

          if [[ -n "${SUBMODULES:-}" ]]; then
            mapfile -t submodule_names < <(parse_list "$SUBMODULES")
            echo "Using ${#submodule_names[@]} submodules from input." >&2
          else
            # Fetch .gitmodules from boostorg/boost at LIBS_REF to discover all libs/ submodules.
            echo "Fetching .gitmodules from boostorg/boost at $LIBS_REF..." >&2
            gitmodules_content=$(gh api \
              "repos/boostorg/boost/contents/.gitmodules?ref=$LIBS_REF" \
              -H "Accept: application/vnd.github.v3.raw" 2>/dev/null) || {
              echo "Failed to fetch .gitmodules" >&2; exit 1
            }
            mapfile -t submodule_names < <(
              echo "$gitmodules_content" \
                | grep '^\s*path\s*=' \
                | sed 's/.*=\s*//' \
                | { grep '^libs/' || true; } \
                | sed 's|^libs/||'
            )
            echo "Found ${#submodule_names[@]} libs submodules." >&2
          fi

          [[ ${#submodule_names[@]} -eq 0 ]] && {
            echo "No submodules to process, nothing to do." >&2; exit 0
          }

          total=${#submodule_names[@]}
          for i in "${!submodule_names[@]}"; do
            sub="${submodule_names[$i]}"
            echo "[$(( i + 1 ))/$total] $sub ..." >&2
            if process_one_submodule "$sub"; then
              UPDATES+=("$sub")
            fi
          done

          finalize_translations_repo "$TRANS_DIR" "$LIBS_REF"

          echo "Done." >&2
